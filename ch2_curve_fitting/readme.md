
```cpp
problem.AddResidualBlock(cost_function, new ceres::CauchyLoss(0.5), &m, &c);
```

ä¸­çš„ `CauchyLoss(0.5)` æ˜¯ **æŸå¤±å‡½æ•°ï¼ˆLoss Functionï¼‰**ï¼Œç”¨äº **é²æ£’åŒ–éçº¿æ€§æœ€å°äºŒä¹˜ä¼˜åŒ–**ï¼Œå®ƒçš„ä½œç”¨æ˜¯ï¼š

---

##  æŸå¤±å‡½æ•°çš„æ„ä¹‰ï¼šå¯¹å¼‚å¸¸å€¼ï¼ˆoutliersï¼‰ä¸æ•æ„Ÿ

é»˜è®¤æƒ…å†µä¸‹ï¼ŒCeres æ±‚è§£çš„æ˜¯æ ‡å‡†çš„ **éçº¿æ€§æœ€å°äºŒä¹˜é—®é¢˜**ï¼Œç›®æ ‡æ˜¯æœ€å°åŒ–ï¼š

$$
\sum_i r_i^2
$$

å…¶ä¸­ $r_i$ æ˜¯æ¯ä¸ªæ®‹å·®é¡¹ residualã€‚ä½†è¿™ç§æ±‚å’Œå¯¹ **ç¦»ç¾¤ç‚¹éå¸¸æ•æ„Ÿ**ï¼Œæ¯”å¦‚ä¸€ä¸ªæµ‹é‡é”™è¯¯å¯¼è‡´ $r_i$ ç‰¹åˆ«å¤§ï¼Œä¼šä¸¥é‡æ‹‰åæ•´ä¸ªä¼˜åŒ–ç»“æœã€‚

ä¸ºäº†æ›´é²æ£’ï¼Œæˆ‘ä»¬å°†å¹³æ–¹æ®‹å·®æ”¹ä¸ºä½¿ç”¨ **æŸå¤±å‡½æ•° Ï**ï¼š

$$
\sum_i \rho(r_i^2)
$$

å…¶ä¸­ $\rho$ æ˜¯ä¸€ä¸ªå¹³æ»‘å‡½æ•°ï¼Œé€šå¸¸è®© **å°çš„æ®‹å·®ä¸å˜ï¼Œä½†å¤§çš„æ®‹å·®æƒé‡ä¸‹é™**ï¼Œä»è€Œå‡å° outlier çš„å½±å“ã€‚

---

##  `CauchyLoss`æŸ¯è¥¿æŸå¤±å‡½æ•° æ˜¯ä»€ä¹ˆï¼Ÿ

`CauchyLoss` æ˜¯ Ceres ä¸­å†…ç½®çš„ä¸€ç§é²æ£’æ ¸å‡½æ•°ï¼Œå…¶æ•°å­¦è¡¨è¾¾æ˜¯ï¼š

$$
\rho(s) = a^2 \cdot \log\left(1 + \frac{s}{a^2} \right)
$$

å…¶ä¸­ï¼š

* $s = r^2$ æ˜¯å¹³æ–¹æ®‹å·®
* $a$ æ˜¯ Cauchy å‚æ•°ï¼ˆä½ ä¼ å…¥çš„ 0.5ï¼‰

  * æ§åˆ¶å¯¹å¼‚å¸¸å€¼çš„â€œå®¹å¿åº¦â€
  * è¶Šå°è¶Šé²æ£’ï¼Œä½†å¯¹æ­£å¸¸å€¼å½±å“ä¹Ÿå¤§

**æ•ˆæœå›¾ç¤ºæ„**ï¼ˆç›¸æ¯”æ ‡å‡†å¹³æ–¹ï¼‰ï¼š

```
Standard loss:        Ï(r^2) = r^2               â† å¯¹å¼‚å¸¸å€¼å¢é•¿å¤ªå¿«
Cauchy loss:          Ï(r^2) â‰ˆ a^2 * log(1 + r^2/a^2)  â† æ”¶æ•›é€Ÿåº¦æ…¢ï¼Œå¯¹å¤§ræŠ‘åˆ¶ä½œç”¨å¼º
```

---

##  å®é™…æ•ˆæœ

### æ²¡æœ‰æŸå¤±å‡½æ•°ï¼š

```cpp
problem.AddResidualBlock(cost_function, nullptr, &m, &c);
```

ä¼˜åŒ–ç›®æ ‡æ˜¯ $\sum r^2$ï¼Œå¯¹å¼‚å¸¸å€¼å¾ˆæ•æ„Ÿã€‚

### æœ‰æŸå¤±å‡½æ•°ï¼ˆé²æ£’ï¼‰ï¼š

```cpp
problem.AddResidualBlock(cost_function, new ceres::CauchyLoss(0.5), &m, &c);
```

ç›®æ ‡å˜æˆ $\sum \rho(r^2)$ï¼Œå¼‚å¸¸å€¼çš„å½±å“è¢«æŠ‘åˆ¶ï¼Œä¼˜åŒ–æ›´ç¨³å¥ã€‚

---

##  æ€»ç»“

| é¡¹ç›®              | æ„ä¹‰                        |
| --------------- | ------------------------- |
| æŸå¤±å‡½æ•° `Ï()`      | å¯¹å¹³æ–¹æ®‹å·®è¿›è¡Œå‹ç¼©ï¼Œå‡å°‘å¼‚å¸¸å€¼å½±å“         |
| `CauchyLoss(a)` | ä¸€ç§å¸¸ç”¨çš„é²æ£’æ ¸å‡½æ•°ï¼Œå‚æ•°è¶Šå°è¶Šé²æ£’        |
| ä½¿ç”¨åœºæ™¯            | æ•°æ®ä¸­å­˜åœ¨å™ªå£°æˆ–ç¦»ç¾¤ç‚¹æ—¶ï¼ˆæ¯”å¦‚å¸¦è¯¯å·®çš„ä¼ æ„Ÿå™¨æµ‹é‡ï¼‰ |

---
åœ¨ Ceres Solver æˆ–å…¶ä»–éçº¿æ€§æœ€å°äºŒä¹˜ä¼˜åŒ–ä¸­ï¼Œ**æŸå¤±å‡½æ•°çš„é€‰æ‹©**å†³å®šäº†ä½ ä¼˜åŒ–è¿‡ç¨‹å¯¹\*\*ç¦»ç¾¤ç‚¹ï¼ˆoutliersï¼‰\*\*çš„é²æ£’æ€§ã€‚é€‰æ‹©åˆé€‚çš„æŸå¤±å‡½æ•°å–å†³äºï¼š

* æ•°æ®ä¸­æ˜¯å¦å­˜åœ¨å¼‚å¸¸å€¼ï¼›
* å¼‚å¸¸å€¼çš„æ¯”ä¾‹ï¼›
* ä½ æ˜¯å¦å…³å¿ƒæ‰€æœ‰æ•°æ®ç‚¹çš„ç²¾ç¡®æ‹Ÿåˆï¼Œè¿˜æ˜¯æ›´å…³æ³¨ä¸»æµæ•°æ®çš„ç¨³å®šæ‹Ÿåˆã€‚

ä¸‹é¢æˆ‘ä»ã€Œå¸¸ç”¨æŸå¤±å‡½æ•°ã€ã€Œå‚æ•°è§£é‡Šã€ã€Œé€‰æ‹©å»ºè®®ã€ä¸‰ä¸ªæ–¹é¢è¿›è¡Œè®²è§£ï¼š

---

##  1. å¸¸è§çš„æŸå¤±å‡½æ•°ç±»å‹

| æŸå¤±å‡½æ•°å              | è¡¨è¾¾å¼ï¼ˆÏ(s)ï¼‰                                                                                               | ç‰¹ç‚¹                  | å‚æ•° |
| ------------------ | ------------------------------------------------------------------------------------------------------- | ------------------- | -- |
| **Noneï¼ˆé»˜è®¤ï¼‰**       | $\rho(s) = s$                                                                                           | æ ‡å‡†æœ€å°äºŒä¹˜ï¼Œå¯¹å¼‚å¸¸å€¼æåº¦æ•æ„Ÿ     | æ—   |
| **HuberLoss**      | $\rho(s) = \begin{cases} s & s \leq \delta^2 \\ 2\delta \sqrt{s} - \delta^2 & s > \delta^2 \end{cases}$ | å¹³æ»‘è¿‡æ¸¡ï¼Œå¯¹å°æ®‹å·®ä¸å˜ï¼Œå¤§æ®‹å·®çº¿æ€§å¢é•¿ | Î´  |
| **CauchyLoss**     | $\rho(s) = a^2 \log(1 + \frac{s}{a^2})$                                                                 | å¼‚å¸¸å€¼æƒé‡ä¸‹é™æ›´å¿«ï¼Œé²æ£’æ€§è¾ƒå¼º     | a  |
| **SoftLOneLoss**   | $\rho(s) = 2a^2(\sqrt{1 + \frac{s}{a^2}} - 1)$                                                          | ç±»ä¼¼ Huberï¼Œä½†æ›´å¹³æ»‘       | a  |
| **ArctangentLoss** | $\rho(s) = a^2 \arctan(s / a^2)$                                                                        | è¾ƒå¼ºé²æ£’æ€§ï¼Œé€‚ç”¨äºæç«¯ç¦»ç¾¤ç‚¹åœºæ™¯    | a  |

---

## 2. å‚æ•°çš„å«ä¹‰ä¸è°ƒèŠ‚

* æ‰€æœ‰å¸¦å‚æ•°çš„æŸå¤±å‡½æ•°éƒ½ä½¿ç”¨ä¸€ä¸ª**å°ºåº¦å‚æ•°**ï¼ˆå¦‚ `Î´` æˆ– `a`ï¼‰ï¼š

  * **è¶Šå°ï¼š** ç¦»ç¾¤ç‚¹æ›´å®¹æ˜“è¢«å½“ä½œå¼‚å¸¸ï¼ˆæ›´é²æ£’ï¼‰ï¼›
  * **è¶Šå¤§ï¼š** è¶‹è¿‘äºæ ‡å‡†æœ€å°äºŒä¹˜ï¼ˆå¯¹å¼‚å¸¸ä¸æ•æ„Ÿï¼‰ã€‚

ä¾‹å¦‚ï¼š

```cpp
new ceres::CauchyLoss(0.5);  // æ›´é²æ£’ï¼Œå¯¹å¼‚å¸¸å€¼å‹åˆ¶æ›´å¼º
new ceres::CauchyLoss(2.0);  // é²æ£’æ€§è¾ƒå¼±ï¼Œæ›´æ¥è¿‘æ ‡å‡†æœ€å°äºŒä¹˜
```

å»ºè®®ä» `0.5 ~ 1.0` å¼€å§‹è°ƒè¯•ï¼Œæ‰¾åˆ°ä¸€ä¸ªèƒ½æ‹Ÿåˆå¤§å¤šæ•°æ•°æ®ä½†ä¸è¿‡åˆ†å¿½ç•¥æ­£å¸¸ç‚¹çš„å€¼ã€‚

---

##  3. å¦‚ä½•é€‰æ‹©æŸå¤±å‡½æ•°

| æƒ…å†µ                  | å»ºè®®ä½¿ç”¨çš„æŸå¤±å‡½æ•°                            |
| ------------------- | ------------------------------------ |
| æ²¡æœ‰å¼‚å¸¸å€¼æˆ–è¯¯å·®éå¸¸å°         | ä½¿ç”¨é»˜è®¤ï¼ˆNoneï¼‰å³å¯                         |
| æœ‰å°‘é‡å¼‚å¸¸å€¼ï¼ˆ< 5%ï¼‰ï¼Œä¸å¤ªæç«¯   | **HuberLoss**ï¼ˆå¹³æ»‘ï¼‰                    |
| å¼‚å¸¸å€¼æ˜æ˜¾åç¦»ï¼ˆå¦‚é”™è¯¯æµ‹é‡ï¼‰ï¼Œæ•°é‡è¾ƒå¤š | **CauchyLoss / SoftLOneLoss**        |
| å¼‚å¸¸å€¼æç«¯ï¼ˆå¦‚é”™è¯¯ä¼ æ„Ÿå™¨ IDã€é‡å€¼ï¼‰ | **ArctangentLoss / TukeyLoss**ï¼ˆæ›´å¼ºæŠ‘åˆ¶ï¼‰ |
| æ‹Ÿåˆè´¨é‡è¦æ±‚é«˜ï¼Œå¯¹ä¸»æ•°æ®æåº¦æ•æ„Ÿ    | **HuberLoss + å¤§å‚æ•°**                  |

---

## ğŸ” 4. ç¤ºä¾‹ï¼šCeres ä¸­ä½¿ç”¨æŸå¤±å‡½æ•°

```cpp
ceres::LossFunction* loss = new ceres::CauchyLoss(0.5);
problem.AddResidualBlock(cost_function, loss, &m, &c);
```

---

##  5. å®è·µå»ºè®®

1. **å…ˆç”¨ None çœ‹æ•ˆæœ**ï¼šä½œä¸º baselineã€‚
2. **åŠ ä¸Š HuberLoss æµ‹è¯•**ï¼šåˆ¤æ–­æ˜¯å¦å­˜åœ¨ç¦»ç¾¤ç‚¹å¹²æ‰°ã€‚
3. **å¦‚æœæ•ˆæœä¸ä½³å†ç”¨ CauchyLoss æˆ– ArctangentLoss**ã€‚
4. **å¯è§†åŒ–æ®‹å·®**ï¼šçœ‹æ˜¯å¦æœ‰æ˜æ˜¾ outlierï¼Œè¾…åŠ©å†³ç­–ã€‚
5. **æ³¨æ„å‚æ•°è°ƒè¯•**ï¼šä¸åŒæ•°æ®é›†å·®å¼‚è¾ƒå¤§ï¼Œ0.5 é€šå¸¸æ˜¯ä¸ªä¸é”™çš„åˆå§‹å€¼ã€‚

---

åœ¨ g2oï¼ˆé€šç”¨å›¾ä¼˜åŒ–æ¡†æ¶ï¼‰ä¸­ï¼Œ`BaseUnaryEdge` æ˜¯ä¸€ä¸ª**æ¨¡æ¿åŸºç±»**ï¼Œç”¨äºå®šä¹‰**ä¸€å…ƒè¾¹**ï¼ˆUnary Edgeï¼‰ï¼Œå³ä»…è¿æ¥**ä¸€ä¸ªé¡¶ç‚¹**çš„è¾¹ã€‚å®ƒæ˜¯ g2o ä¸­æ„å»ºè¯¯å·®è¾¹çš„æ ¸å¿ƒç±»ä¹‹ä¸€ï¼Œä¸»è¦ç”¨äºä»¥ä¸‹åœºæ™¯ï¼š

---

### **1. æ ¸å¿ƒä½œç”¨**
`BaseUnaryEdge` çš„ä½œç”¨æ˜¯ï¼š
- **å®šä¹‰è¯¯å·®é¡¹**ï¼šè®¡ç®—è§‚æµ‹å€¼ä¸æ¨¡å‹é¢„æµ‹å€¼ä¹‹é—´çš„å·®å¼‚
- **è¿æ¥å•ä¸ªé¡¶ç‚¹**ï¼šå°†è¯¯å·®ä¸å¾…ä¼˜åŒ–çš„ä¸€ä¸ªé¡¶ç‚¹å‚æ•°å…³è”
- **æä¾›è‡ªåŠ¨å¾®åˆ†æ¥å£**ï¼šæ”¯æŒè§£ææˆ–æ•°å€¼è®¡ç®—é›…å¯æ¯”çŸ©é˜µ

---

### **2. æ¨¡æ¿å‚æ•°**
```cpp
template <int D, typename E, typename VertexXi>
class BaseUnaryEdge : public BaseEdge<D, E>
```
- **`D`**ï¼šè¯¯å·®çš„ç»´åº¦ï¼ˆä¾‹å¦‚ï¼š1ç»´æ ‡é‡è¯¯å·®ã€2ç»´åƒç´ è¯¯å·®ç­‰ï¼‰
- **`E`**ï¼šæµ‹é‡å€¼çš„æ•°æ®ç±»å‹ï¼ˆä¾‹å¦‚ï¼š`double`ã€`Eigen::Vector2d`ï¼‰
- **`VertexXi`**ï¼šè¿æ¥çš„é¡¶ç‚¹ç±»å‹ï¼ˆä¾‹å¦‚ï¼š`VertexSE3`ã€`VertexPointXYZ`ï¼‰

---

### **3. å…³é”®æˆå‘˜å‡½æ•°**
| å‡½æ•° | ä½œç”¨ | æ˜¯å¦å¿…é¡»å®ç° |
|------|------|-------------|
| `computeError()` | è®¡ç®—è¯¯å·® | âœ… å¿…é¡» |
| `linearizeOplus()` | è®¡ç®—é›…å¯æ¯”çŸ©é˜µ | âŒ å¯é€‰ï¼ˆä½†æ¨èï¼‰ |
| `read()` / `write()` | æ•°æ®åºåˆ—åŒ– | âŒ å¯é€‰ |

---

### **4. å…¸å‹ä½¿ç”¨åœºæ™¯**
#### **åœºæ™¯ 1ï¼šæ›²çº¿æ‹Ÿåˆ**
```cpp
// å®šä¹‰è¾¹ï¼šy = axÂ² + bx + c çš„è¯¯å·®
class CurveFittingEdge : public g2o::BaseUnaryEdge<1, double, VertexABC> {
    void computeError() override {
        const VertexABC* v = static_cast<VertexABC*>(_vertices[0]);
        _error[0] = _measurement - (v->a() * x*x + v->b() * x + v->c());
    }
};
```

#### **åœºæ™¯ 2ï¼šä¼ æ„Ÿå™¨æ ¡å‡†**
```cpp
// å®šä¹‰è¾¹ï¼šæ¿€å…‰é›·è¾¾æµ‹è·è¯¯å·®
class LidarEdge : public g2o::BaseUnaryEdge<1, double, VertexLidarParams> {
    void computeError() override {
        const VertexLidarParams* v = static_cast<VertexLidarParams*>(_vertices[0]);
        _error[0] = _measurement - v->calculateDistance();
    }
};
```

#### **åœºæ™¯ 3ï¼šä½å§¿ä¼°è®¡**
```cpp
// å®šä¹‰è¾¹ï¼šé‡æŠ•å½±è¯¯å·®ï¼ˆç®€åŒ–ç‰ˆï¼‰
class ReprojectionEdge : public g2o::BaseUnaryEdge<2, Eigen::Vector2d, VertexSE3> {
    void computeError() override {
        const VertexSE3* v = static_cast<VertexSE3*>(_vertices[0]);
        _error = _measurement - camera.project(v->pose() * point3d);
    }
};
```

---

### **5. ä¸å…¶å®ƒè¾¹ç±»çš„å¯¹æ¯”**
| è¾¹ç±»å‹ | è¿æ¥é¡¶ç‚¹æ•° | å…¸å‹åº”ç”¨ |
|--------|------------|----------|
| `BaseUnaryEdge` | 1ä¸ª | æ›²çº¿æ‹Ÿåˆã€ä¼ æ„Ÿå™¨æ¨¡å‹ |
| `BaseBinaryEdge` | 2ä¸ª | ç‚¹-ä½å§¿çº¦æŸã€ICP |
| `BaseMultiEdge` | â‰¥2ä¸ª | å¤šä¼ æ„Ÿå™¨èåˆ |

---

### **6. å®ç°æ³¨æ„äº‹é¡¹**
1. **å†…å­˜å¯¹é½**ï¼š
   ```cpp
   EIGEN_MAKE_ALIGNED_OPERATOR_NEW // å¿…é¡»æ·»åŠ 
   ```
2. **è¯¯å·®æ–¹å‘**ï¼š
   ```cpp
   _error = prediction - measurement; // æˆ–åè¿‡æ¥
   ```
3. **é›…å¯æ¯”çŸ©é˜µ**ï¼š
   - è‹¥æœªå®ç° `linearizeOplus()`ï¼Œg2o ä¼šä½¿ç”¨æ•°å€¼å·®åˆ†ï¼ˆæ•ˆç‡ä½ï¼‰

---

### **7. å®Œæ•´ç¤ºä¾‹ä»£ç **
```cpp
// å®šä¹‰ä¸€å…ƒè¾¹ï¼šy = kx + b çš„çº¿æ€§æ‹Ÿåˆ
class LinearEdge : public g2o::BaseUnaryEdge<1, double, VertexLineParams> {
public:
    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
    LinearEdge(double x, double y) : _x(x), _measurement(y) {}

    void computeError() override {
        const VertexLineParams* v = static_cast<VertexLineParams*>(_vertices[0]);
        _error[0] = (_measurement - (v->k() * _x + v->b()));
    }

    void linearizeOplus() override {
        _jacobianOplusXi[0] = -_x;  // âˆ‚e/âˆ‚k = -x
        _jacobianOplusXi[1] = -1;   // âˆ‚e/âˆ‚b = -1
    }

private:
    double _x; // è¾“å…¥çš„xå€¼
};
```

---

### **8. ä¸ºä»€ä¹ˆé€‰æ‹© `BaseUnaryEdge`ï¼Ÿ**
- **ç®€å•æ€§**ï¼šæ¯” `BaseBinaryEdge` æ›´æ˜“å®ç°
- **æ•ˆç‡**ï¼šæ¯”é€šç”¨çš„ `BaseMultiEdge` æ›´é«˜æ•ˆ
- **æ¸…æ™°æ€§**ï¼šæ˜ç¡®è¡¨ç¤º"ä¸€ä¸ªè§‚æµ‹å¯¹åº”ä¸€ä¸ªå¾…ä¼˜åŒ–å˜é‡"çš„å…³ç³»

é€šè¿‡ç»§æ‰¿ `BaseUnaryEdge`ï¼Œç”¨æˆ·å¯ä»¥å¿«é€Ÿæ„å»ºå„ç§ä¸€å…ƒè¯¯å·®çº¦æŸï¼Œæ˜¯ g2o ä¸­æœ€å¸¸ç”¨çš„è¾¹ç±»å‹ä¹‹ä¸€ã€‚